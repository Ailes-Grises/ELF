このディレクトリは，ELFファイルの解析を行うディレクトリである．
ELFファイルの構造理解を主目的としており，最終的には逆アセンブルすることを目的としている．

 - Device クラスは，バイナリファイルの配列へのダンプと基本的な読み出し機能を提供しており，それぞれ1, 2, 4, 8 Bytes の読み出しが可能である(エンディアンはフラグで対応)．
 - Elf クラスでは，ELFヘッダの解析を実現している．
 - 現在，セクションヘッダとプログラムヘッダに関しては別途クラスを作成することを検討中．
 - セクションヘッダのパーサが完成してからの話だが，Intelやその他のアーキテクチャのニーモニック命令テーブルを別途ヘッダファイルとして用意する必要がある．

2020/04/18

 - readelf -h の表示が不明瞭であったため，一部の表示を変更した．
 - セクションヘッダの役割がいまいちわからなかったが，ようやく概要を理解した．
 - セクションヘッダーテーブルはオブジェクトファイルに唯一つだけ存在し，その正体は Elf64_Shdr 構造体型の配列である．以下に概要を示す．

 $ Elf64_Shdr arr[obj.e_shnum];
 $ 
 $ arr[] = [セクション0の構造体]
 $         [セクション1の構造体]
 $         [セクション2の構造体]
 $                  .
 $                  .
 $                  .
 $                  .
 $         [セクションobj.e_shnumの構造体]

 - 現在，ELFヘッダの解析が完了しており，次はセクションヘッダの解析を行う．
 - セクションヘッダには役割毎にそれぞれ特別な名前がついており，各セクションのセクションヘッダはオブジェクトファイルの一番末尾に敷き詰められている．
 - とりあえず，逆アセンブルを行う上で最も重要なのは .text セクションで，ここには機械語の命令文が格納されている．


2020/04/20

 - 長らく各セクションヘッダの先頭要素であるuint32_t sh_name の役割がわからなかったが，ようやくわかった．
 -> この要素の保持している値は，.shstrtabセクション内のインデックスなのだが，どうやら「.shstrtabセクションの先頭アドレスからsh_nameバイトの位置にある'\0'で始まる文字列が，このセクションヘッダの名前です」という意味のようである．
 -> 実際，.shstrtabセクションの先頭アドレスは0x00007edc だが，2個目のセクションヘッダ(0x00008068)のsh_nameは0x1bで，0x000007dc から0x1b Bytes(つまり27Bytes)目の位置から始まる文字列の名前は"\0.interp"であった．これは，"readelf -S sampleO0.out"で確認すると，確かに2番目のセクションヘッダの名前であった．

 - 本日はセクションヘッダの詳細を表示する関数の実装を行った．未だ完成していないが，セクション名を入手するためには，専用の関数を用意したほうが良いかも知れない．


2020/04/25

 - 本日はセクションヘッダの名前を入手する関数を作成する．
 - セクションヘッダから名前を入手するには，.shstrtab の冒頭から sh_name Bytes の位置にアクセスする必要がある．この際，データの読み出しは*dc を介して行っているため，名前の取得の際には該当位置までジャンプする関数を利用する必要がある．
 - この関数は，指定アドレスまでジャンプすると同時に，ジャンプする直前の位置も保持して置かなければならない．

 - 予想以上にアセンブリの仕組みに近いコードを書く必要がありそうだ．なんならジャンプ処理の部分はインラインアセンブラでもいいかもw
 - スタックポインタやプログラムカウンタ，リンクレジスタなどをエミュレートした方が良い．すなわち，今回のプログラムでは*dc がプログラムカウンタの役割をしているが，ジャンプ先から再帰する際に必要な，ジャンプ元のアドレスを保持するポインタが別途必要になる．恐らくこれがスタックポインタである．ARMのCPUでは，この再帰専用レジスタのことをリンクレジスタと呼んでいる．

 - いずれにせよ，プログラムの構造自体をもう一度見直したほうが良い(今の構造もそう悪くはない)．

2020/04/26

 - git を導入した．現状をマスターブランチに登録し，そちらに関しては一切いじっていない．
 - 今後は，現在のブランチであるInheritanceブランチで開発を行う．継承を解除する作業が終わったら，このブランチをmasterにマージして，別のブランチで開発を行う．


2020/04/27

 - Inheritanceブランチにて，継承の解体作業が完了した．本当に継承なんか使わなくても実現できてしまった．今後，継承を使うことは二度と無いだろう．
 - まだコミットしていない．エラーも出ていないし，一応masterブランチの実行結果も確認したが，全く変わらなかったため，すぐにでもマージして問題ないと思われる．
 - この後は，別ブランチにてSection::showshdr()の.sh_nameの取得関数を実装する．
 - 実装の際には，アーキテクチャの構造を意識して，堅牢な設計をすること(具体的には，スタックポインタやプログラムカウンタをちゃんと実装することを考える)．
 - 現状，何か見直すことがあるとすれば，Device::dc の宣言の仕方をもう一回吟味したほうが良いかも知れない(staticとか，グローバル化とか，publicメンバにするとか)．
 - このプログラムが完成したら，いよいよデバイスドライバやBIOSエミュレータの実装に移る．

 - P.S. uint8_t* Device::dc のstatic 宣言を削除した．動作確認済み．


2020/04/29

 - sh_nameを取得するため，get-sh_nameブランチを作成した．当初は*dcをジャンプさせようとしていたが，考えてみればただデータを取得するだけなので，別でスタックポインタを設けて，それをデータアクセス専用ポインタとして目的地まで飛ばすことにする．
 - スタックポインタとして，Deviceクラスに uint8_t *sp を追加した．コンストラクタで初期化済み．
 // - 名前を取得する為に，SectionクラスにSectoin::getstring() 関数を用意した．そっくりな機構で，普通のint等のデータも取得できるようになるはず．
 - Deviceクラスの既存のget8bit()などは，内部で直接uint8_t *dc を更新していたため，uint8_t *sp を使ってデータの読み出しを行う為に，別の関数を用意することにした．名前は，Device::getChar() である．
 - 場合によっては，Deviceクラス内に，これをオーバーラップしたgetString() を作成しても良いかも知れない．

 - セクション名の取得に成功した．かなり多くの加筆を行ったが，構造的に致命的な問題は今の所見つかっていない．
 - 主な加筆点としては，
   > SectionクラスからDeviceクラスのポインタ(*dc, *sp)の値を参照・変更する必要が出てきたため，これらポインタにアクセスする各種関数をDeviceクラスに追加した．
	 > このプログラム内におけるプログラムカウンタの役割を果たしている*dcを直接ジャンプさせるのは不適切であると考えたため，新たにスタックポインタである*spをDeviceクラスに追加した．sh_nameの具体的な名前の取得の際には，このポインタを介してアクセスしている．
	 > 従来のDebice::get8bit()では，内部で*dcを直接更新しているため，新たに内部で*spを更新するDevice::getChar()を作成した．

 - 本日の進捗はこんな所である．今後やるべきこととしては，
   > Deviceクラス内のgetDC()やgetDATA()などの名前を変更する． => ok
	 > 現在使用されているmalloc()を全てnewに書き直す． => ok
	 > Section::showshdr()内のループ処理で，'34'というマジックナンバーが使用されているため，これを直す． => ok
	 > 現時点ではまだ各セクションの名前を表示する所までしか実装出来ていないため，ちゃんと画面表示を完成させる． => Flagsの直前までok

 - まだコミットするなよ!


2020/05/01

 - sh_flags 以前の各パラメータの画面表示が完了した．elf.hの冒頭にマクロ定義として新しく画面表示の制御コードであるsetw_left/right(wd) を追加し，画面のアラインメントを完全にこれで制御した．
 - sh_flagsの値は，2進数で表記された各パーミッション(A, X 等)の総和を16進数で表したものである．よって，この値を元の2進数に戻してから，1のフラグが立っている場所のパーミッションを画面表示すれば良い．
 - 16進数を2進数に変換する必要があるため，各種進数変換関数を独立したユーザ関数として，device.hに実装することにする．
 - 現在の作業ブランチであるget-sh_nameのブランチ名を変更した．名前は"shdr_analysis"とする．

 - ここで一旦コミットすることにする．


2020/05/02

 - セクションヘッダの解析に関する全ての実装が完了した．
 - 前回のコミットからの大きな加筆点は以下の通り:
   > device.hに各種進数変換を行う関数を実装した
	 > Flagの画面表示を実装した
	 > セクションヘッダ解析の画面表示を完璧に調整した

 - 進数変換関数は，2進数の性質を非常に巧妙に利用しており，考え方に関してかなり新しい発見があった．この関数は，解析自体には一切関与していない．
 - sh_flags のフラグ名の取得に関しては，2進数の論理積の性質を非常にうまく利用している．具体的には，sh_flags の値と，/usr/include/elf.hで定義された各フラグとの論理積の結果が，フラグの値と同じかどうかでフラグの状態(パーミッション的な)を判断している．考え方としては，ネットマスクに近い．

 - ここでコミットを行う．このブランチにおける新たな開発は基本的に無いだろう．次はプログラムヘッダの解析や，シンボルテーブルの解析を行う予定．


=========== ここからphdr_analysis ブランチ ===========


2020/05/03

 - パーサの構築まで完了した．そもそもこのヘッダは対してやることが無いため，ここまで本当に一瞬で出来てしまった．
 - Section::show_shdr() だが，Typeの画面表示の歳，if-else で書いているが，あそこまで条件がシンプルならswitch文で書き直すべきである．elf.ccに関しても然り． => ok
 - Program::show_phdr() にて，p_typeのswitch文記述の際，同じ値のフラグが存在するせいでエラーが発生した．どうやらSun Micro Systems 系のOS特有の予約フラグが存在するらしく，これが他のフラグと被ってしまっている．よって，該当箇所をコメントアウトした． => ok
 - 全てのソースファイル(elf.cc, device.cc, program.cc)において，if文を削除した．全てswitch文になっている．
 - readelf -l sampleO0.out の上半分の部分に関しては完全に再現できた．色々と調整済み．下半分は，何をやっているのかちょっと分からないので，後日実装する．
 - 本日の作業の冒頭で，32bitのアーキテクチャにも対応できるように改変しようとしたが，例えテンプレートを利用したとしてもかなり面倒臭そうだったため，これを中断した．
 - 考えてみれば，世の中のデバイスドライバやアプリケーションなどは，ダウンロードの段階で32bitと64bitを選択しているわけであり，そもそも同じプログラムでbit数の異なるアーキテクチャを扱うほうが間違っていた．
 - あと，ソースファイルやヘッダファイルの名前を変更した．具体的には，(elf.cc -> elf64.cc)等の様にした．device.h/cc に関しては変更していない(bit数依存が無かったため)

 - とりあえずここでコミットを行う．

 - 今度は readelf -l の下半分の実装を行う．この部分は，どうやらセグメントとセクションの包括関係を表にして表示しているようである．

2020/05/05

 - プログラムヘッダに記された各パラメータが，ファイル内のオフセットと一致しないため，readelf -l の詳細を本で調べている．
 - どうやら，OffsetとFilSiz がELFファイル内におけるセグメントのアドレスオフセットとサイズで，VirtAddrとMemSiz はセグメントがマップ(ロード)される仮想アドレス空間内のアドレスオフセットとメモリ領域のサイズを表しているらしい．

 - readelf.cc にオプション解析を実装しようとした所，予期せぬエラーが発生．エラーメッセージは以下の通り(恐ろしい/(@0@)\;;)
   > (a.out: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) ...orz...)' )
 - 原因は，Elfクラスのパーサが呼ばれる前にSectionクラスとProgramクラスのコンストラクタが呼び出されていたことだった．このエラーは，パーサをユーザが明示的に呼び出さないと実行されないことが原因であると考えたため(どのみちどこかでパーサを発動しないと何も出来ない)，パーサをコンストラクタの内部で呼び出すことにした．
 - また，今までメンバ関数内から，同一クラスの他のメンバ関数を呼ぶためには通行証として自分と同じクラスのインスタンスを参照渡しで受け取っていたが，考えてみればこれはthisポインタを使えば完全に不要なコードであった．恐らく，神澤先生が授業でクラスの参照渡しを使っていたのは，演算子の実装など，同じクラスのインスタンスが2つ以上必要であったからであると考えられる．

 - 以上より，全てのクラスにおいて，
   > メンバ関数内で同一クラスの他のメンバ関数を呼び出すときには*thisを使用
	 > 余計な参照渡しを全て削除
	 > 各クラスのコンストラクタ内でパーサの呼び出しを行う
   
	 という変更を加えた．

 - 本当は readelf -l の後半部分の実装も行う予定だったが，やはり各セグメントのファイル内における割り当てがよく分からないのと，よく考えたらセグメントの情報は逆アセンブルには必要ないなと思ったので，セクションヘッダの開発は一旦ここで終了とする．

 - ここでコミットしてmasterにマージする．

2020/05/11

 - 新たにsymtab_analysis というブランチを作成し，ここでシンボルテーブルの解析を行う．
 - 機械語が格納されているのは.text セクションだが，それを解析して元のアセンブリコードを調べたとしても，コード中で変数や関数を参照する際にはスタック領域に毎回アクセスする必要がある．この時に利用される，シンボル名とそのアドレスのセットを格納するのがシンボルテーブルである．
 - シンボルテーブルは，/usr/include/elf.h にて，Elf64_Sym という構造体で管理されている．


 * 現在の疑問点
  > スタック領域はどこか? -> ELFファイル内には無い．本物のコンピュータのメモリ空間の末尾周辺に存在する．
	> シンボルテーブルの実際の使われ方が微妙に分からない．
	> シンボルテーブルとシンボルハッシュテーブルがある(!?) -> シンボルテーブルの中でも，ハッシュ構造になっているものをシンボルハッシュテーブルと呼んでいるだけ．
	> どこかでハッシュを使う気がするのだが，どこだ？ -> シンボルハッシュテーブル周りの実装で使うんじゃね?(シンボルハッシュテーブルの役割がまだわかっていない)

 - とりあえず.symtab セクションの中身を吸い出すクラスを作成する．

 - シンボルテーブルには2種類ある．.dynsym と.symtab セクションに格納されている．.symtabセクションのシンボルテーブルは，文字通り変数などのシンボル情報を格納する．.symtabの参照するシンボル名は，実際には.strtabに格納されており，Elf64_Symのst_nameメンバは，このセクション内のオフセットである．
 - また，.dynsymセクションのシンボルテーブルは，ダイナミックリンクに関するシンボル名を格納しており，その文字列の実態は.dynstrに格納されている．

 2020/05/20

 - 上記の通り，シンボルテーブルは，実行ファイル内で扱われるマングリングされたシンボル名(つまり変数名)と，そのシンボルがローダによって実際のメモリ上にコピーされた時の本物のメモリ空間上におけるアドレスが格納されている．
 - ただ，シンボル名自体はELFファイルのどこかにまとめて格納されているはずなので，それはそれでシンボル名とそのファイルオフセットがちゃんと結びつくように何らかのテーブルを作成する必要がある(sh_name の様な方法でアクセスすることもできるけどね)．
 - だから，シンボルに関するテーブルには「シンボルテーブル」と「シンボルハッシュテーブル」が存在するのだろう(どっちがどっちかはまだ分からない)．


 - 上記は全然違うかも知れない．
 - シンボルテーブルは目的ごとに複数存在し，中でもハッシュ構造が使用されているシンボルテーブルをシンボルハッシュテーブルと呼んでいる．

 - シンボルテーブルというと，「複数のシンボルの情報を一括で管理している表」みたいな印象を与えるが，実際にはそうではない．
 - シンボルテーブルは，ある１つのシンボルが持つ「シンボル名・値・変数(つまり型)のサイズ・スコープ・このシンボルと関連するセクションのセクション番号」をひとまとめにした構造体である．したがって，恐らくシンボルの数だけこの構造体が存在する．
 - この構造体が，多分いくつかのセクション内に敷き詰められている(例えば.symtabとか)．
 - ダイナミックリンク関係のシンボルテーブル構造体は.dynsymへ，それ以外のシンボルテーブル構造体は.symtabに格納されている．
 - 過去にも書いたが，.dynsymのシンボル名を保持するセクションは.dynstrであり，.symtabのシンボル名を保持するセクションは.strtabである(多分)．
 - シンボルテーブルは，Elf64_Sym 構造体型の配列で実装できるはず(セクションヘッダーテーブルと全く同じ考え方)．


 $ Elf64_Sym arr[シンボルテーブルの個数];
 $ 
 $ // .symtab と.dynsym の中身を，それぞれ以下の構造の配列にダンプすれば良い．
 $ arr[] = [シンボル0の構造体]
 $         [シンボル1の構造体]
 $         [シンボル2の構造体]
 $                  .
 $                  .
 $                  .
 $                  .
 $         [シンボルNの構造体]


 - .hash についてだが，これはどうやら再配置時に動的リンカが使用するセクションの様である．このセクション内にある何らかのハッシュテーブルを使うことで，.dynsym 内のシンボルを，線形探索せずに迅速に見つけられるようになるらしい．...だったらどっかに書いとけよ. 

 - 脆弱性を発見．section.cc において，実はgetsh_name() はshow_shdr() の内部でしか呼ばれていない．つまり，実行する際，./readelf -S を実行する前にstd::string* Section::sh_name を参照すると，予期せぬエラーとなる．
   > 解決．Section::sh_parser() でstd::string* Section::sh_name の初期化まで行った．

==== ここでコミット．

 - Section クラスのパーサでstd::string *sh_name を一通り初期化した後，こいつらをまとめてハッシュにぶち込めばいいじゃん！そうすればセクション名からそのインデックスを検索できるぞ！
   > 実装済み．ハッシュ値も確認したが，問題なかった．これでセクション名からセクション番号を割り出せる．


 - Symbol::Symbol() のswitch 文とenum 周りがおかしい．次回はそこから実装すること． => 解決済み
 - Symbol クラスのコンストラクタまで実装した．動作確認済み．enum を導入した．


2020/05/22

 - Symbol クラスのコンストラクタや，その他必要なprivate メンバ，及びそれに付随する必要な関数(ハッシュ関数やメンバの読み出し関数，名前取得関数など)を追加した．
 - Section クラスと全く同じ要領で，シンボル名を格納する変数とハッシュを定義した．
 - Device クラスのprivate メンバのint fsize とそれに関連する関数を削除した．
 - 現状コンパイルエラーは無し．

 - 改善点を以下に示す:
   > いろんなクラスでmemset やってない． => ok. 
	 > new のエラー処理やってない所が多数．
	 > Device クラスにおいて，不必要な引数(自クラスのインスタンス)がたくさんある． => ok. 
	 > 可能なら，vim の正規表現のツールとして，完全にperl と同じ文法のものをインストールすべき．

 - 上記の色々な問題をだいたい解決した．ただし，エラー処理関係はもしかしたら真面目にtry-catch した方が良いかも．
 - 次回はパーサの実装から始めること．

 2020/05/24

 - やっとスマートポインタの基本的な使い方を理解した．
 - 福田先生のコードを参考にした．あの人はstd::vector<>の中にstd::string ってしてた．ひょっとして各クラスのnew ってほぼ必要無いんじゃね..?
 - using std::cout 系をdevice.h に記述した．全ての関連ファイルで置換済み．

 - [疑問点]
   > スマートポインタで書いた場合，エラーで異常終了してもメモリーリークは回避できるのか?(スコープしか見てないなら，エラー処理を工夫しないとやばいかも．)
   > スマートポインタで書いた場合，デストラクタで領域開放を行う必要はあるのか?

 - 別ブランチでポインタを全てスマートポインタにし，device クラスのコンストラクタ以外でnew している部分を全てstd::vector<> に変更する．
 - その際，このシンボルクラスのブランチはローカルにプッシュしておいた方が良い．

 - symbol クラス用のenum は必要ないかも知れない．
 - symbol クラスのインスタンス生成のタイミングでは，既にセクション名のハッシュテーブルが初期化されているはずなので，symbol クラスのコンストラクタでセクション名を直接もらい(const std::string)，これをハッシュ関数にぶち込めば必要な領域サイズも分かる．
 - したがって，switch 文とenum の必要性が消滅する!

 - Symbol::show_symtab() のst_info の出力まで完成した．他のクラスの画面表示も汚いから修正したほうが良い．
 - Symbol クラスの画面表示までの全行程が完了した．現状エラーなし．

 - [現状の問題点]
   > エラー処理はやっていない．
	 > new で領域確保している部分が多すぎる．Device クラスのコンストラクタ以外はstd::vector でほぼ代用できるはず．

 - 次は，スマートポインタ及びnew を大幅に削減するブランチを作成して，コードのスマートポインタ化を行う．
 - このブランチは，ローカルにpush したほうが良い．

 - ここでコミットする．


====== ここからsmart_ptr ブランチ ======


2020/05/26

 - スマートポインタを実装する前に，先にnew で作成していた構造体型配列を，std::vector で書き直す．

2020/06/25

 - std::vector で構造体型配列を書き直そうと思ったが，実はstd::vector を使う方が不都合であることが発覚．
 - 具体的には，std::vector を使うメリットとしては，配列の要素数がわかっていなくても良いことと，プログラマが領域開放を行わなくても良い事である．しかし，今回は必要な領域の範囲がわかっているし，std::vector を使うとむしろ領域のコピーと再確保，開放を繰り返すことになるため，こっちの方が効率が悪い．
 - よって，構造体型配列の作成は，従来通りnew による一括管理で実現するものとする．

 - これより，各クラスのスマートポインタ化を行う．


 2020/08/22

 - Device クラスの宣言を全てshared_ptr に書き直した．動作確認済み．
 - unique_ptr の使い方が分からなくて福田先生のコードを見たが，なんかそもそも俺とはちょっと違う考え方してるっぽい．なんか発想が違う．

 - 全てのクラスのスマートポインタ化が完了した．動作確認済み．master ブランチにマージした．


2020/08/26

 - git のlog にはいよいよ.text セクションの解析を行うと書いたが，その前に再配置情報の解析とダイナミックリンクに関する構造体の解析を行う必要がある．
 - 今回はリンクが完了したオブジェクトファイルの逆アセンブルが目的なので，解析対象ファイルに再配置情報は存在しない．したがって，再配置情報を格納する構造体であるElf64_Rel(a) 構造体の解析はスキップし，ダイナミックリンク情報を保持するElf64_Dyn 構造体の解析を行う．

 - dynamic クラスの実装がほぼ完了した．後は表示を少し調整したら完了．
 - 画面表示のswitch 文があまりにも面倒だったので，perl で書いた．

 - dynamic クラスの実装が完了した．画面表示に関しては，めんどくさかったので一部適当に表示してある．

 - ここで一旦コミットする．次は.text セクションの実装に取り掛かる．

 - とりあえず.text セクションの中身を別のファイルに吐き出してみたが，ルールがさっぱり分からない．Intel のCPU はCISC なので，命令長もバラバラだから正直仕様書が無いと辛い．もしかしたら0000 で区切っているのかも知れないが，法則性が分からない．
