このディレクトリは，ELFファイルの解析を行うディレクトリである．
ELFファイルの構造理解を主目的としており，最終的には逆アセンブルすることを目的としている．

 - Device クラスは，バイナリファイルの配列へのダンプと基本的な読み出し機能を提供しており，それぞれ1, 2, 4, 8 Bytes の読み出しが可能である(エンディアンはフラグで対応)．
 - Elf クラスでは，ELFヘッダの解析を実現している．
 - 現在，セクションヘッダとプログラムヘッダに関しては別途クラスを作成することを検討中．
 - セクションヘッダのパーサが完成してからの話だが，Intelやその他のアーキテクチャのニーモニック命令テーブルを別途ヘッダファイルとして用意する必要がある．

2020/04/18

 - readelf -h の表示が不明瞭であったため，一部の表示を変更した．
 - セクションヘッダの役割がいまいちわからなかったが，ようやく概要を理解した．
 - セクションヘッダーテーブルはオブジェクトファイルに唯一つだけ存在し，その正体は Elf64_Shdr 構造体型の配列である．以下に概要を示す．

 $ Elf64_Shdr arr[obj.e_shnum];
 $ 
 $ arr[] = [セクション0の構造体]
 $         [セクション1の構造体]
 $         [セクション2の構造体]
 $                  .
 $                  .
 $                  .
 $                  .
 $         [セクションobj.e_shnumの構造体]

 - 現在，ELFヘッダの解析が完了しており，次はセクションヘッダの解析を行う．
 - セクションヘッダには役割毎にそれぞれ特別な名前がついており，各セクションのセクションヘッダはオブジェクトファイルの一番末尾に敷き詰められている．
 - とりあえず，逆アセンブルを行う上で最も重要なのは .text セクションで，ここには機械語の命令文が格納されている．


2020/04/20

 - 長らく各セクションヘッダの先頭要素であるuint32_t sh_name の役割がわからなかったが，ようやくわかった．
 -> この要素の保持している値は，.shstrtabセクション内のインデックスなのだが，どうやら「.shstrtabセクションの先頭アドレスからsh_nameバイトの位置にある'\0'で始まる文字列が，このセクションヘッダの名前です」という意味のようである．
 -> 実際，.shstrtabセクションの先頭アドレスは0x00007edc だが，2個目のセクションヘッダ(0x00008068)のsh_nameは0x1bで，0x000007dc から0x1b Bytes(つまり27Bytes)目の位置から始まる文字列の名前は"\0.interp"であった．これは，"readelf -S sampleO0.out"で確認すると，確かに2番目のセクションヘッダの名前であった．

 - 本日はセクションヘッダの詳細を表示する関数の実装を行った．未だ完成していないが，セクション名を入手するためには，専用の関数を用意したほうが良いかも知れない．


2020/04/25

 - 本日はセクションヘッダの名前を入手する関数を作成する．
 - セクションヘッダから名前を入手するには，.shstrtab の冒頭から sh_name Bytes の位置にアクセスする必要がある．この際，データの読み出しは*dc を介して行っているため，名前の取得の際には該当位置までジャンプする関数を利用する必要がある．
 - この関数は，指定アドレスまでジャンプすると同時に，ジャンプする直前の位置も保持して置かなければならない．

 - 予想以上にアセンブリの仕組みに近いコードを書く必要がありそうだ．なんならジャンプ処理の部分はインラインアセンブラでもいいかもw
 - スタックポインタやプログラムカウンタ，リンクレジスタなどをエミュレートした方が良い．すなわち，今回のプログラムでは*dc がプログラムカウンタの役割をしているが，ジャンプ先から再帰する際に必要な，ジャンプ元のアドレスを保持するポインタが別途必要になる．恐らくこれがスタックポインタである．ARMのCPUでは，この再帰専用レジスタのことをリンクレジスタと呼んでいる．

 - いずれにせよ，プログラムの構造自体をもう一度見直したほうが良い(今の構造もそう悪くはない)．


